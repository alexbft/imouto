// Generated by CoffeeScript 1.10.0
var FFMPEG, Ivona, child_process, config, convertMp3ToOpus, fs, googleTts, isJap, isKor, isRus, ivona, ivonaTts, logger, misc, pq, tmp;

child_process = require('child_process');

tmp = require('tmp');

fs = require('fs');

logger = require('winston');

Ivona = require('ivona-node');

ivona = null;

config = require('../lib/config');

pq = require('../lib/promise');

misc = require('../lib/misc');

FFMPEG = config.options.ffmpeg;

isJap = function(c) {
  return (c >= '\u3000' && c <= '\u303f') || (c >= '\u3040' && c <= '\u309f') || (c >= '\u30a0' && c <= '\u30ff') || (c >= '\uff00' && c <= '\uffef') || (c >= '\u4e00' && c <= '\u9faf');
};

isKor = function(c) {
  return (c >= '\u3130' && c <= '\u318f') || (c >= '\uac00' && c <= '\ud7af');
};

isRus = function(c) {
  return c >= 'А' && c <= 'Я' || c >= 'а' && c <= 'я';
};

googleTts = function(txt, lang) {
  return misc.getAsBrowser("https://translate.google.com/translate_tts", {
    qs: {
      ie: 'UTF-8',
      tl: lang,
      q: txt,
      total: 1,
      idx: 0,
      textlen: txt.length,
      client: 't'
    },
    encoding: null
  });
};

ivonaTts = function(txt, lang) {
  var accessKey, df, ref, secretKey, voiceStream;
  df = new pq.Deferred;
  lang = {
    'en': 'en-US',
    'ru': 'ru-RU'
  }[lang];
  if (lang == null) {
    df.resolve({
      error: 'lang'
    });
  } else {
    if (ivona == null) {
      ref = config.options.ivona.split(':'), accessKey = ref[0], secretKey = ref[1];
      ivona = new Ivona({
        accessKey: accessKey,
        secretKey: secretKey
      });
    }
    voiceStream = ivona.createVoice(txt, {
      body: {
        Voice: {
          Language: lang,
          Gender: 'Female'
        },
        OutputFormat: {
          Codec: 'OGG'
        }
      }
    });
    misc.readStream(voiceStream, df.callback());
  }
  return df.promise;
};

convertMp3ToOpus = function(mp3) {
  var args, cmd, df, proc, tmpFile;
  df = new pq.Deferred;
  tmpFile = tmp.fileSync({
    postfix: '.ogg'
  });
  tmpFile.removeCallback();
  tmpFile.removeCallback = function() {
    return fs.unlinkSync(tmpFile.name);
  };
  args = "-v error -i - -acodec libopus \"" + tmpFile.name + "\"";
  cmd = "\"" + FFMPEG + "\" " + args;
  logger.info("Running: " + cmd);
  proc = child_process.exec(cmd, function(err, stdout, stderr) {
    var e, error;
    if (err) {
      return df.reject(err);
    } else {
      try {
        process.stdout.write(stdout);
        process.stdout.write(stderr);
        return df.resolve(tmpFile);
      } catch (error) {
        e = error;
        return df.reject(e);
      }
    }
  });
  proc.stdin.write(mp3);
  proc.stdin.end();
  return df.promise;
};

module.exports = {
  name: 'Voice tts',
  isConf: true,
  isPrivileged: true,
  warnPrivileged: true,
  pattern: /!(голос|войс|voice|speak|v|tts|няк|nya|desu|десу)(?:\s+(.+))?$/,
  onMsg: function(msg, safe) {
    var chars, lang, nya, ref, txt;
    txt = msg.match[2];
    if (txt == null) {
      if (((ref = msg.reply_to_message) != null ? ref.text : void 0) != null) {
        txt = msg.reply_to_message.text;
      } else {
        logger.info("No text");
        return;
      }
    }
    chars = txt.split('');
    if (chars.some(isRus)) {
      lang = 'ru';
    } else {
      lang = 'en';
    }
    nya = msg.match[1].toLowerCase();
    if ((nya === 'няк' || nya === 'nya' || nya === 'desu' || nya === 'десу') && (lang === "ja" || lang === "en" || lang === "ru")) {
      if (nya === 'няк' || nya === 'nya') {
        nya = {
          "ja": "にゃ",
          "en": "nyah",
          "ru": "ня"
        }[lang];
      } else if (nya === 'desu' || nya === 'десу') {
        nya = {
          "ja": "ですう",
          "en": "desoo",
          "ru": "дэсу"
        }[lang];
      } else {
        nya = 'wtf';
      }
      txt = txt.replace(/([\!\?\.\,])/g, " " + nya + "$1");
      if (!/([\!\?\.\,])$/.test(txt)) {
        txt = txt + (" " + nya + "!");
      }
    }
    if (txt.length > 200 && !this.isSudo(msg)) {
      msg.reply("Текст слишком длинный!");
      return;
    }
    logger.info("Voicing: " + txt);
    return safe(ivonaTts(txt, lang)).then((function(_this) {
      return function(ogg) {
        if (ogg.error != null) {
          msg.send('Не знаю такого языка!');
          return;
        }
        if (ogg.message != null) {
          return logger.error(ogg.message);
        } else {
          logger.debug("Got bytes: " + ogg.length);
          return msg.sendVoice(ogg);
        }
      };
    })(this));
  },
  onError: function(msg) {
    return msg.send("Я сегодня не в голосе.");
  }
};
