// Generated by CoffeeScript 1.10.0
var addSign, config, degToCard, forecast, getWeatherFull, icon, keyboard, logger, misc, moment, offset, states, timezone, tz, weather;

logger = require('winston');

tz = require('coordinate-tz');

moment = require('moment-timezone');

misc = require('../lib/misc');

config = require('../lib/config');

states = require('../lib/country_codes');

moment.locale('ru');

degToCard = function(deg) {
  var directions, section, sectionDegrees;
  sectionDegrees = 360 / 16;
  section = Math.round(deg / sectionDegrees) % 16;
  directions = ['–°', '–°–°–í', '–°–í', '–í–°–í', '–í', '–í–Æ–í', '–Æ–í', '–Æ–Æ–í', '–Æ', '–Æ–Æ–ó', '–Æ–ó', '–ó–Æ–ó', '–ó', '–ó–°–ó', '–°–ó', '–°–°–ó'];
  return directions[section];
};

icon = function(type) {
  switch (type) {
    case "01d":
      return "‚òÄÔ∏è";
    case "01n":
      return "‚òÄ";
    case "02d":
      return "üå§";
    case "02n":
      return "üå§";
    case "03d":
      return "‚òÅÔ∏è";
    case "03n":
      return "‚òÅÔ∏è";
    case "04d":
      return "‚òÅÔ∏è";
    case "04n":
      return "‚òÅÔ∏è";
    case "09d":
      return "üåß";
    case "09n":
      return "üåß";
    case "10d":
      return "üå¶";
    case "10n":
      return "üå¶";
    case "11d":
      return "üå©";
    case "11n":
      return "üå©";
    case "13d":
      return "üå®";
    case "13n":
      return "üå®";
    case "50d":
      return "üå´";
    case "50n":
      return "üå´";
  }
};

timezone = function(lat, lon) {
  return tz.calculate(lat, lon).timezone;
};

offset = function(timezone) {
  return function(date) {
    var tzdate;
    tzdate = moment(date);
    return tzdate.tz(timezone);
  };
};

forecast = function(cityName, lat, lon, lang) {
  var qs;
  qs = {
    units: 'metric',
    lang: lang,
    appid: config.options.weathermap
  };
  if (cityName != null) {
    qs.q = cityName;
  } else {
    qs.lat = lat;
    qs.lon = lon;
  }
  return misc.get('http://api.openweathermap.org/data/2.5/forecast', {
    qs: qs,
    json: true
  });
};

weather = function(cityName, lat, lon, lang) {
  var qs;
  qs = {
    units: 'metric',
    lang: lang,
    appid: config.options.weathermap
  };
  if (cityName != null) {
    qs.q = cityName;
  } else {
    qs.lat = lat;
    qs.lon = lon;
  }
  return misc.get('http://api.openweathermap.org/data/2.5/weather', {
    qs: qs,
    json: true
  });
};

addSign = function(x) {
  if (x > 0) {
    return "+" + x;
  } else {
    return "" + x;
  }
};

keyboard = [
  [
    {
      text: '–ù–∞ –≤–µ—á–µ—Ä',
      callback_data: 'evening'
    }, {
      text: '–°–µ–π—á–∞—Å',
      callback_data: 'now'
    }, {
      text: '–ù–∞ –∑–∞–≤—Ç—Ä–∞',
      callback_data: 'tomorrow'
    }
  ]
];

getWeatherFull = function(data) {
  var dateFrom, sunrise, sunset, type, zone;
  type = icon(data['weather'][0]['icon']);
  zone = timezone(data['coord']['lat'], data['coord']['lon']);
  sunrise = sunset = dateFrom = offset(zone);
  return data.name + ", " + states[data.sys.country] + " " + (data.jsdt ? dateFrom(data.jsdt).fromNow() : '') + "\n\n" + type + " " + data.weather[0].description + "\nüå° " + (addSign(Math.round(data.main.temp))) + " ¬∞C\nüí¶ " + data.main.humidity + "%\nüí® " + data.wind.speed + " –∫–º/—á, " + (degToCard(data.wind.deg)) + "\nüåÖ " + (sunrise(data.sys.sunrise * 1000).format('LT')) + "\nüåÑ " + (sunset(data.sys.sunset * 1000).format('LT'));
};

module.exports = {
  name: 'Weather',
  pattern: /!(weather|–ø–æ–≥–æ–¥–∞|!–ø–æ–≥–æ–¥–∞|!weather)(?: (.+))?/,
  isConf: false,
  isAcceptMsg: function(msg) {
    return (msg.location != null) || this.matchPattern(msg, msg.text);
  },
  onMsg: function(msg, safe) {
    var cmd, forecst, inlineMode, lang, latitude, longitude, ref, res, txt;
    if (msg.location != null) {
      ref = msg.location, latitude = ref.latitude, longitude = ref.longitude;
      res = weather(null, latitude, longitude, 'ru');
      forecst = forecast(null, latitude, longitude, 'ru');
      inlineMode = true;
    } else {
      cmd = msg.match[1].toLowerCase();
      lang = cmd === 'weather' || cmd === '!weather' ? 'en' : 'ru';
      inlineMode = cmd === '!–ø–æ–≥–æ–¥–∞' || cmd === '!weather';
      moment.locale(lang);
      txt = msg.match[2];
      res = weather(txt, null, null, lang);
      forecst = forecast(txt, latitude, longitude, lang);
      if (txt == null) {
        return;
      }
    }
    return safe(res).then((function(_this) {
      return function(data) {
        if (data.cod !== 200) {
          logger.debug(data);
          return msg.reply('–ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω.');
        } else {
          if (inlineMode) {
            return _this.sendInline(msg, data, safe(forecst));
          } else {
            return msg.send(getWeatherFull(data));
          }
        }
      };
    })(this));
  },
  sendInline: function(msg, data, forecast) {
    var context;
    context = {
      current: data,
      now: data
    };
    return msg.send(getWeatherFull(data), {
      inlineKeyboard: keyboard,
      callback: (function(_this) {
        return function(cb, msg) {
          return _this.onCallback(context, cb, msg, forecast);
        };
      })(this)
    });
  },
  updateInline: function(context, data) {
    context.msg.edit(getWeatherFull(data), {
      inlineKeyboard: keyboard
    }).then(function(res) {
      if ((res != null ? res.message_id : void 0) != null) {
        return context.current = data;
      }
    });
  },
  onCallback: function(context, cb, msg, forecast) {
    var filterBy, fiveDays, tomorrow;
    tomorrow = moment.unix(context.now.dt).add(1, 'days').startOf('day');
    context.msg = msg;
    fiveDays = forecast.then(function(res) {
      return res.list.map(function(v) {
        return Object.assign(v, {
          coord: context.now.coord,
          name: res.city.name,
          sys: Object.assign(v.sys, {
            country: res.city.country,
            sunrise: context.now.sys.sunrise,
            sunset: context.now.sys.sunset
          }),
          jsdt: moment.unix(v.dt)
        });
      });
    });
    filterBy = function(promise, predicate) {
      return promise.then(function(res) {
        return res.filter(predicate);
      });
    };
    switch (cb.data) {
      case 'now':
        this.updateInline(context, context.now);
        break;
      case 'evening':
        filterBy(fiveDays, function(arg) {
          var jsdt;
          jsdt = arg.jsdt;
          return jsdt.isBefore(tomorrow);
        }).then((function(_this) {
          return function(res) {
            return _this.updateInline(context, res[res.length - 1]);
          };
        })(this));
        break;
      case 'tomorrow':
        filterBy(fiveDays, function(arg) {
          var jsdt;
          jsdt = arg.jsdt;
          return jsdt.isAfter(tomorrow);
        }).then((function(_this) {
          return function(res) {
            return _this.updateInline(context, res[1]);
          };
        })(this));
    }
  },
  onError: function(msg) {
    return msg.reply('–ö–∞–∂–µ—Ç—Å—è, –¥–æ–∂–¥—å –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è.');
  }
};
