// Generated by CoffeeScript 1.12.6
var Deferred, Promise, PromiseCallback, exports;

if ((typeof module === "undefined" || module === null) && (typeof window !== "undefined" && window !== null)) {
  exports = window.$p = {};
}

PromiseCallback = (function() {
  function PromiseCallback(func1) {
    this.func = func1;
    this.deferred = new Deferred();
  }

  PromiseCallback.prototype.promise = function() {
    return this.deferred.promise;
  };

  PromiseCallback.prototype.execute = function(value) {
    var err, retValue;
    try {
      retValue = this.func(value);
      if (retValue instanceof Promise) {
        return retValue.then((function(_this) {
          return function(realValue) {
            return _this.deferred.resolve(realValue);
          };
        })(this));
      } else {
        return this.deferred.resolve(retValue);
      }
    } catch (error) {
      err = error;
      return this.deferred.reject(err);
    }
  };

  return PromiseCallback;

})();

exports.Promise = Promise = (function() {
  Promise.UNRESOLVED = 0;

  Promise.RESOLVED = 1;

  Promise.REJECTED = 2;

  function Promise() {
    this.status = Promise.UNRESOLVED;
    this.value = null;
    this.error = null;
    this.callbacks = [];
    this.rejectCallbacks = [];
  }

  Promise.prototype.then = function(func, funcElse) {
    var callback;
    callback = new PromiseCallback(func);
    switch (this.status) {
      case Promise.UNRESOLVED:
        this.callbacks.push(callback);
        break;
      case Promise.RESOLVED:
        this._execute(callback);
    }
    if (funcElse != null) {
      this["else"](funcElse);
    }
    return callback.promise();
  };

  Promise.prototype["else"] = function(func) {
    switch (this.status) {
      case Promise.UNRESOLVED:
        this.rejectCallbacks.push(func);
        break;
      case Promise.REJECTED:
        func(this.error);
    }
    return this;
  };

  Promise.prototype["finally"] = function(func) {
    return this.then(func, func);
  };

  Promise.prototype._resolve = function(value) {
    var callbacks, cb, j, len;
    if (this.status !== Promise.UNRESOLVED) {
      throw new Error("State is " + this.status + " - cannot resolve");
    }
    this.status = Promise.RESOLVED;
    this.value = value;
    callbacks = this.callbacks;
    this.callbacks = null;
    this.rejectCallbacks = null;
    for (j = 0, len = callbacks.length; j < len; j++) {
      cb = callbacks[j];
      this._execute(cb);
    }
  };

  Promise.prototype._execute = function(cb) {
    return cb.execute(this.value);
  };

  Promise.prototype._reject = function(err) {
    var callbacks, cb, j, len, rejectCallbacks;
    this.status = Promise.REJECTED;
    this.error = err;
    rejectCallbacks = this.rejectCallbacks;
    callbacks = null;
    this.rejectCallbacks = null;
    if ((rejectCallbacks != null) && rejectCallbacks.length > 0) {
      for (j = 0, len = rejectCallbacks.length; j < len; j++) {
        cb = rejectCallbacks[j];
        cb(this.error);
      }
    } else {
      throw this.error;
    }
  };

  return Promise;

})();

exports.Deferred = Deferred = (function() {
  function Deferred() {
    this.promise = new Promise();
  }

  Deferred.prototype.resolve = function(value) {
    return this.promise._resolve(value);
  };

  Deferred.prototype.reject = function(err) {
    return this.promise._reject(err);
  };

  Deferred.prototype.callback = function() {
    return (function(_this) {
      return function(err, value) {
        if (err != null) {
          return _this.reject(err);
        } else {
          return _this.resolve(value);
        }
      };
    })(this);
  };

  return Deferred;

})();

exports.asPromise = function(invocation) {
  var deferred;
  deferred = new Deferred();
  invocation(deferred.callback());
  return deferred.promise;
};

exports.all = function(promises) {
  var counter, deferred, fn, i, j, len, p, results;
  deferred = new Deferred();
  counter = promises.length;
  results = [];
  fn = function(i) {
    p.then(function(res) {
      counter -= 1;
      results[i] = res;
      if (counter <= 0) {
        deferred.resolve(results);
      }
    });
    return p["else"](function(err) {
      return deferred.reject(err);
    });
  };
  for (i = j = 0, len = promises.length; j < len; i = ++j) {
    p = promises[i];
    fn(i);
  }
  return deferred.promise;
};

exports.resolved = function(value) {
  var deferred;
  deferred = new Deferred();
  deferred.resolve(value);
  return deferred.promise;
};
